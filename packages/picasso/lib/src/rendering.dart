import 'dart:async';
import 'dart:ui' as ui;

import 'package:duffer/duffer.dart';
import 'package:picasso/picasso.dart';

class RenderOutput {

  /// Serialized [CanvasSaveData] of the canvas.
  /// Empty buffer if rendered using imageOnly flag.
  final ByteBuf data;

  /// Image or video output of the canvas, depending on
  /// the used [RenderDirector] and [PicassoCanvasState] implementation.
  final ByteBuf image;

  /// Render Metadata generated by present tools.
  final Map<String, dynamic> metadata;

  RenderOutput(this.data, this.image, this.metadata);
}


abstract class RenderDirector {
  const RenderDirector();

  Future<RenderOutput> render(PicassoCanvasState state, {bool imageOnly = false});

}

class FallbackRenderDirector implements RenderDirector {
  const FallbackRenderDirector();

  @override
  Future<RenderOutput> render(PicassoCanvasState state, {bool imageOnly = false}) {
    var ratio = state.widget.settings.width / state.canvasSize.width;
    var completer = Completer<RenderOutput>();
    state.performRenderPass(() async {
      var image = await state.renderRepaintBoundary.toImage(pixelRatio: ratio);
      var pngData = await image.toByteData(format: ui.ImageByteFormat.png);
      var saveBuffer = imageOnly ? Unpooled.fixed(0) : await PicassoSaveSystem.instance.save(state);
      var imageBuffer = pngData!.buffer.asUint8List().asWrappedBuffer;
      completer.complete(RenderOutput(saveBuffer, imageBuffer, state.annotatedRenderData));
    });
    return completer.future;
  }
}